Implementation Notes
--------------------
Switched from direct interpretation to pre-compiling interpret mode lines
	Facilitates branching /loops, which don't work in a direct-interpreted context
	Necessitated pre-compiling and executing the current scratch buffer when
	switching to compile mode, to keep things consistent
Broke down lua "newfunc/define" functionality into more basic primitives
	Moved definition of ":" from lua lang to firth land
	Uncovered compile-mode switch bug
		If the last word on an interpreted line switch to compile, infinite recursion
		This is because it calls:
			compiler:done(), on EOL
			which compiles, executes scratch buffer
			which sets compile mode true
			which triggers state transition logic
			which calls compiler:end()
			which compiles, executes scratch buffer...
		The Fix:
			clear scratch buffer as soon as it is first compiled
			bail from done() if compilebuffer is empty or nil
		New bug:
			because it bails if buffer is empty...
			: NOP ( -- ) ; // will never leave compile mode
		New Fix:
			just comment out the nil/empty check
			let it compile and empty function
	


Ideas / TODOs
-------------
stack data type
	: stack ( -- stack ) compiler.stack:push(stack.new()) ;
	: >s ( stack x -- stack ) stack:push(x) ;
	: s> ( stack -- stack x ) compiler.stack:push(compiler.stack:top():pop())
	stack 1 >s 2 >s 3 >s s> s> s> .S 
better error debug messagges (xpcall and debug lib)
	if "debug mode", compile in a local var that counts firth source line
recurse
	start all defs with -> "local function word()"
	compile as append "word()"
	end all defs with -> "end \n return word"
variables
	a variable is a word
		by default, pushes its own dict entry
		has no compilebuf
		once initialized, has a .data field
	does> ( entry -- )
		compiles and binds a func
			pushes the variable's entry
			calls the supplied word
		expects a dict entry on stack for a variable
		grabs the next token, extracts entry's func field
		sets var.func = word.func
	variable ( name -- entry )
		: variable ( ) newentry dup does> nop dup bindfunc ; // pushes, doesn't touch entry
	var: ( x -- )
		: var: ( ) nextword variable ! ;
	@ ( entry -- x )
		pushes value of var.data
	! ( x entry -- )
		sets var.data
	defined? ( name -- b )
refactor scratch/last scheme
	instead of scratch or last, push onto cstack
	make this more flexible and controllable from firth land?
	should set us up for nested functions/lambdas
access lua tables form firth land
	table.field ( t k -- v )
		pop fieldname from stack
		pop table from stack
		push field with given name
	.field: name ( t -- v )
		immediate word so it can grab a field name token
		compiles itself as:
			push word
			push "table.field"
			call
		: .field: ( -- ) nextword push table.field ;immed
	compiler
		lua prim
		function prims.compiler(compiler) compiler.stack:push(compiler) end
	dictionary
		: dictionary ( -- dict ) compiler .field: dictionary ;
	'
		for this to work, push has to assign tables to a local tmp, and compile to push that name?
		: ' ( -- ) dictionary nextword table.field push ;immed
multiline control structures and comments
	pending parse callback if parsing unsatisfied at end of line?
		char ) parse => if didn't actually find it, run parse again on next line
	flow control in interpret mode
		call interpretpending() whenever we hit an immediate
		if, loops, etc.
			push self.compiling onto cstack
			self.compiling = true
			set compile target to a scratch buffer (need to rework scratch/last scheme)
			append lua keyword
		end
			append "end"
			pop self.compiling from cstack
			if not compiling anymore, build and execute
	multiline comments
		in a loop, read and throw away lines from input device until close comment
		need to rework compiler input scheme
			lines(file) returns an iterator function; useful?
		version of parse that returns whether the delimiter was found
			we can keep looping if not found
			regular parse uses this and drops the result?
compilebuf dump
	break into more primitive words and implement in firth
param pattern matching
	core compiler/language feature?
	implemented through metaprogramming?
	// assumes something like : concat ( s1 s2 -- s1s2 ) ... ;
	: strreps	( s n -- n*s )
				(( _ 1 )) drop
				(( _ _ )) over swap loops over concat end swap drop
	;
runtime documentation
	call lists
		if foo is deleted or redefined, remove from bar.calledby
	attach stack diagram comments to words as a docstring
	attach preceding comments to words, in a specific form?
		append string to EOL, to internal buffer
		: checks this buffer, and attaches to dict entry, if it exists
syntax highlighting
	tokens can set self format and next-parsed format
	parse finds begin and end span for currently-set formatting
	found word can alway override its own formatting when "executed"
	variables to set
		wordstyle // default for any word
		numberstyle // default for numbers
		selfstyle // override for how to style this word (local?)
		wordstyle @ gray var: compilerstyle // wordstyle but gray; useful for styling compiler words
create a vocabulary for writing executable grammars for parsing DSLs
whittle the lua codebase down to
	generic io and string handling
	access table fields
	compile buffers to lua functions
	call lua functions