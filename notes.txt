Implementation Notes
--------------------
Switched from direct interpretation to pre-compiling interpret mode lines
	Facilitates branching /loops, which don't work in a direct-interpreted context
	Necessitated pre-compiling and executing the current scratch buffer when
	switching to compile mode, to keep things consistent
Broke down lua "newfunc/define" functionality into more basic primitives
	Moved definition of ":" from lua lang to firth land
	Uncovered compile-mode switch bug
		If the last word on an interpreted line switch to compile, infinite recursion
		This is because it calls:
			compiler:done(), on EOL
			which compiles, executes scratch buffer
			which sets compile mode true
			which triggers state transition logic
			which calls compiler:end()
			which compiles, executes scratch buffer...
		The Fix:
			clear scratch buffer as soon as it is first compiled
			bail from done() if compilebuffer is empty or nil
		New bug:
			because it bails if buffer is empty...
			: NOP ( -- ) ; // will never leave compile mode
		New Fix:
			just comment out the nil/empty check
			let it compile and empty function
	


Ideas / TODOs
-------------
experimental optimization branch
	precache table lookups as closed-over locals in compiled code, where possible
		locals outside of function, that the function closes over
		track which methods, structures, word funcs, and fields are accessed
		implies we get the forthy redefinition behavior (original always called)
	two parallel dictionaries
		one stores the thing that we care about
			compiled function -> call it
			anything else -> push it?
		one stores all the metadata
			compilebuf
			calls and calledby
			whatever else
	inline functions
		compiles to an immediate that compiles the firth code in the body inline
		implies immediate
		explicit?
			: ;inline postpone interpret compilebuf inlinefunc bindfunc immediate ;immed
		automatic?
			fewer than x words in def?
			fewer than y lines of generate lua in compilebuf?
	aliases
		simply adds a second key that points to the same value
		eliminates an additional call overhead for convenience words
		: [ ( -- ) postpone interpret ;immed	// current way
		' interpret alias: [					// new way
	pre-cache used lua library functions as locals and close over them
		bitops
		stringio
access lua tables form firth land
	table.field ( t k -- v )
		pop fieldname from stack
		pop table from stack
		push field with given name
	.field: name ( t -- v )
		immediate word so it can grab a field name token
		compiles itself as:
			push word
			push "table.field"
			call
		: .field: ( -- ) nextword push table.field ;immed
	compiler
		lua prim
		function prims.compiler(compiler) compiler.stack:push(compiler) end
	dictionary
		: dictionary ( -- dict ) compiler .field: dictionary ;
	'
		for this to work, push has to assign tables to a local tmp, and compile to push that name?
		: ' ( -- ) dictionary nextword table.field push ;immed
multiline control structures and comments
	flow control in interpret mode
		call interpretpending() whenever we hit an immediate
		if, loops, etc.
			push self.compiling onto cstack
			self.compiling = true
			set compile target to a scratch buffer (need to rework scratch/last scheme)
			append lua keyword
		end
			append "end"
			pop self.compiling from cstack
			if not compiling anymore, build and execute
	multiline comments
		in a loop, read and throw away lines from input device until close comment
		need to rework compiler input scheme
			lines(file) returns an iterator function; useful?
		version of parse that returns whether the delimiter was found
			we can keep looping if not found
			regular parse uses this and drops the result?
compilebuf dump
	break into more primitive words and implement in firth
param pattern matching
	core language feature?
	implemented through metaprogramming?
runtime documentation
	call lists
		if foo is deleted or redefined, remove from bar.calledby
	attach stack diagram comments to words as a docstring
	attach preceding comments to words, in a specific form?
		append string to EOL, to internal buffer
		: checks this buffer, and attaches to dict entry, if it exists
create a vocabulary for writing executable grammars for parsing DSLs
whittle the lua codebase down to
	generic io and string handling
	access table fields
	compile buffers to lua functions
	call lua functions