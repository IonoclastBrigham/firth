Implementation Notes
--------------------
Switched from direct interpretation to pre-compiling interpret mode lines
	Facilitates branching /loops, which don't work in a direct-interpreted context
	Necessitated pre-compiling and executing the current scratch buffer when
	switching to compile mode, to keep things consistent
Broke down lua "newfunc/define" functionality into more basic primitives
	Moved definition of ":" from lua lang to firth land
	Uncovered compile-mode switch bug
		If the last word on an interpreted line switch to compile, infinite recursion
		This is because it calls:
			compiler:done(), on EOL
			which compiles, executes scratch buffer
			which sets compile mode true
			which triggers state transition logic
			which calls compiler:end()
			which compiles, executes scratch buffer...
		The Fix:
			clear scratch buffer as soon as it is first compiled
			bail from done() if compilebuffer is empty or nil
		New bug:
			because it bails if buffer is empty...
			: NOP ( -- ) ; // will never leave compile mode
		New Fix:
			just comment out the nil/empty check
			let it compile and empty function
	


Ideas / TODOs
-------------
experimental optimization branch
	checks and cleanup tasks
		new compiler:trace(str) method, only prints if self.tracing == true
		Make sure [ and ] work, since compile looks for target on stack
		back up compiling? on cstack in eval, and restore at end
	inline functions
		compiles to an immediate that compiles the firth code in the body inline
		implies immediate
		explicit?
			: ;inline postpone interpret compilebuf inlinefunc bindfunc immediate ;immed
		automatic?
			fewer than x words in def?
			fewer than y lines of generate lua in compilebuf?
	pre-cache used lua library functions as locals and close over them
		string
		io
		stringio
		table
	compile time optimization module
		likely to be complicated
			load as a separate, optional module
			patch itself into the compiler machinery
		calculate stack deltas
			: foo bar baz ;
			foo.delta = bar.delta + baz.delta
			capture stack usage even for immediates that compile executable code
				+.consumes = 2
				+.writes = 1
		build a simple tree to represent input
			use knowledge of ops and stack usage to group expressions
			transform and optimize tree is possible
			generate lua code from optimized tree
		stack elision
			use locals wherever possible
			commit stack changes lazily
			pre-calculate results when literals are arguments?
stack data type
	: stack ( -- stack ) compiler.stack:push(stack.new()) ;
	: >s ( stack x -- stack ) stack:push(x) ;
	: s> ( stack -- stack x ) compiler.stack:push(compiler.stack:top():pop())
	stack 1 >s 2 >s 3 >s s> s> s> .S 
better error debug messagges (xpcall and debug lib)
	if "debug mode", compile in a local var that counts firth source line
recurse
	start all defs with -> "local function word()"
	compile as append "word()"
	end all defs with -> "end \n return word"
local variables
	given name mapped to new temp variable
	in nested situations, should we be pushing the locals map?
	local ( name -- )
		new primitive word, analogue to variable
		must only be used from an immediate because it alters compile state
		local function newlocal()
			local name = stack:pop()
			compiler:newlocal(name, nil)
		end
		function compiler:newlocal(name, initialval)
			self.target.locals[name] = compiler:newtmp(initialval)
		end
	local? ( name -- b )
		new immediate prim word
		compiler:push(target.locals[name] ~= nil)
	setl ( x name -- )
		new prim, analogue to !
		must only be used from an immediate because it alters compile state
		local function setlocal()
			local name = stack:pop()
			local val = stack:pop()
			compiler:setlocal(name, val)
		end
		function compiler:setlocal(tmpname, value)
			self:append(tmpname..'='..tostring(value))
		end
	local: ( x -- ) // TS: name
		new primitive word, analogue to var:
		must be immediate because it alters compile state, reads input token
		: local: ( ) nextword dup local setl ;immed
	locals: ( -- ) // TS: names...
		allocates a list of local variables
		probably most useful at the top of a word def
		every space-delimited token following on the line is a new var name?
		: locals: ( ) char \n parse char %s split each local end ;immed
	setl: ( x -- ) // TS: name
		new prim, no analogue with global variables
		unlike !, this must be immediate to read tokens
		updates (but does not define) a local variable
		: setl: ( ) nextword setl ;immed
	=: (x -- ) // TS: name
		defines or updates a local, like go?
		immediate; checks at compile time which action to compile?
		: =: ( )
			nextword dup local? if
				setl
			else
				dup local setl
			end
		;immed
	e.g...
		// uses a local to keep the stack cleaner
		0 =: width
		100 loops
			nextfield dup printcontent widefield? if
				50 setl: width	// will print a wide break
			else
				25 setl: width	// will print a narrower break
			end
			// ...doing who knows what with the stack...
			width loops char . .raw end CR 
		end
	process for compiling a token becomes
		1. check target.locals[token]
		2. if not found, check dictionary
		3. if not found, attempt numeric conversion
		4. if fails, lookup error
	print user's locals in stack traces?
		at top level, or first after dumptrace
		reverse lookup on func 
		pull locals map from entry
access lua tables form firth land
	compiler
		new prim word
		local function pushcompiler() stack:push(compiler) end
	dictionary
		: dictionary ( -- dict ) compiler " dictionary" @@ ;
		or, for efficiency...
		local function pushdict() stack:push(dictionary) end
refactor scratch/last scheme
	should set us up for nested functions/lambdas
multiline comments and strings
	pending parse callback if parsing unsatisfied at end of line?
		char ) parse => if didn't actually find it, run parse again on next line
	in a loop, read and throw away lines from input device until close comment?
		need to rework compiler input scheme
			lines(file) returns an iterator function; useful?
		version of parse that returns whether the delimiter was found
			we can keep looping if not found
			regular parse uses this and drops the result?
param pattern matching
	core compiler/language feature?
	implemented through metaprogramming?
	// assumes something like : concat ( s1 s2 -- s1s2 ) ... ;
	: strreps	( s n -- n*s )
				(( _ 1 )) drop
				(( _ _ )) over swap loops over concat end swap drop
	;
runtime documentation
	call lists
		if foo is deleted or redefined, remove from bar.calledby
	attach stack diagram comments to words as a docstring
	attach preceding comments to words, in a specific form?
		append string to EOL, to internal buffer
		: checks this buffer, and attaches to dict entry, if it exists
syntax highlighting
	tokens can set self format and next-parsed format
	parse finds begin and end span for currently-set formatting
	found word can alway override its own formatting when "executed"
	variables to set
		wordstyle // default for any word
		numberstyle // default for numbers
		selfstyle // override for how to style this word (local?)
		wordstyle @ gray var: compilerstyle // wordstyle but gray; useful for styling compiler words
create a vocabulary for writing executable grammars for parsing DSLs
whittle the lua codebase down to
	generic io and string handling
	access table fields
	compile buffers to lua functions
	call lua functions