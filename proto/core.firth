char //see:comment_block_below_for_copyright_notice drop

char : create compile
	char %s parse create compile
	interpret buildfunc bindfunc
: immediate
	compile_target.XT @@ immediates true pivot !! drop
	interpret buildfunc bindfunc
: %s
	char %s cpush
	interpret buildfunc dup bindfunc immediate
: word
	%s parse
	interpret buildfunc bindfunc
: `
	word cpush
	interpret buildfunc dup bindfunc immediate
: postpone
	word ccall
	interpret buildfunc dup bindfunc immediate
: ;
	buildfunc bindfunc
	interpret buildfunc dup bindfunc immediate
: ;immed
	buildfunc dup bindfunc immediate
	interpret buildfunc dup bindfunc immediate

: skipch  -1 backtrack ;
: 2skipch -2 backtrack ;
: " skipch ` [^"]* parsematch cpush skipch ;immed
: parseline " ^[^\n]*" fmt parsematch ;
: // parseline
	compiling if
		2 -1 Lua.string.sub srcappend char \n srcappend
	else
		drop
	end
	;immed // There, now we can comment our code!

// /////////////////////////////////////////////////////////////////////////////
// core.firth
// Core vocabulary for :Firth environments.
//
// Copyright © 2015-2021 Brigham Toskin
// This file is part of the :Firth language reference implementation. Usage
// and redistribution of this software is governed by the terms of a modified
// MIT-style license. You should have received a copy of the license with the
// source distribution; if not, you may find it online at:
// <https://github.com/IonoclastBrigham/firth/blob/master/LICENSE.firth>
//
// Formatting:
//	utf-8 ; unix ; 80 cols ; tabwidth 4
// /////////////////////////////////////////////////////////////////////////////

// text and parsing words
: ( 1 backtrack " %b()" parsematch
	dup countlines
	compiling if 3 -1 Lua.string.sub srcappend else drop end
	;immed ( ( nestable) parentheses)
: (--) ;immed // shortcut, no stack effects
: (C:  2 backtrack postpone ( ;immed // cstack effects
: (--)(C: postpone (C: ;immed
: (R:  2 backtrack postpone ( ;immed // rstack effects
: (--)(R: postpone (R: ;immed
: (IO: 3 backtrack postpone ( ;immed // iostack effects
: (--)(IO: postpone (IO: ;immed
: (TS: 3 backtrack postpone ( ;immed // token stream effects
: (--)(TS: postpone (TS: ;immed
: (CB: 3 backtrack postpone ( ;immed // compile buf effects
: (--)(CB: postpone (CB: ;immed
: (EX: 3 backtrack postpone ( ;immed // execution effects for compiling words
: (--)(EX: postpone (EX: ;immed
: TODO: (TS: .*\n) postpone // ;immed  TODO: add to list with file/line/word?
: ' ( -- xt )  (TS: word ) word lookup cpush ;immed
: "" ( -- s ) ` (.-)"" parsematch trim cpush ;immed
: clips ( s -- s' ) 2 -2 Lua.string.sub ;
: eachword ( * s xt -- *) ; TODO: parse words from string and hand to xt
: .. (EX: s1 s2 -- s1..s2) " .." cbinop ;immed

// some basic arithmetic operators
: + (EX: a b -- a+b ) char + cbinop ;immed
: - (EX: a b -- a-b ) char - cbinop ;immed
: * (EX: a b -- a*b ) char * cbinop ;immed
: / (EX: a b -- a/b ) char / cbinop ;immed
: % (EX: a b -- a%b ) char % cbinop ;immed
: ** (EX: a b -- a^b ) char ^ cbinop ;immed // use ** because ^ is bit-wise xor

: 1+ ( n -- n' ) 1 + ;

: cpushvar ( name -- )(CB: push(dict[name])) cpush ' lookup ccall ;
: cstorevar ( name -- )(CB: dict[name]=x)
	cpush dictionary cpush ' swap ccall (EX: x -- x dict name)
	' !! ccall ' drop ccall
	;
: ++ (EX: -- n+1 )(TS: nvar )
	word dup cpushvar ' 1+ ccall ( -- name )(EX: -- n+1 )
	' dup ccall cstorevar
	;immed

// some basic boolean operators
: > ( a b -- a>b ) char > cbinop ;immed
: < ( a b -- a<b ) char < cbinop ;immed
: = ( a b -- a==b ) " ==" cbinop ;immed
: >= ( a b -- a>=b ) " >=" cbinop ;immed
: <= ( a b -- a<=b ) " <=" cbinop ;immed
: ~= ( a b -- a!=b ) " ~=" cbinop ;immed
: 2not ( a b -- ~a ~b) swap not swap not ;
: && ( a b -- a&&b ) " and" cbinop ;immed
: || ( a b -- a||b ) " or" cbinop ;immed
: ^^ ( a b -- aXORb ) postpone 2not postpone ~= ;immed
: ~&& ( a b -- !a&&b ) postpone and not ;immed
: ~|| ( a b -- !a||b ) postpone or not ;immed

// compile stack
: C@ ( -- x )(C: x -- x ) cstack []@ ;
: C> ( -- x )(C: x -- ) cstack []> ;
: >C ( x -- )(C: -- x ) cstack >[] drop ;
: Cclear (--)(C: * -- ) cstack []clear ;

// Lambdas, functions, etc.
0 dictionary ` __firth_lambdaID !! drop
` __λ_0x%08X__ dictionary ` __firth_lambdaID_fmt !! drop
: nextλID ( -- s ) ++ __firth_lambdaID __firth_lambdaID_fmt fmt ;
: :( (--) nextλID create compile ;immed
: ); ( -- xt ) buildfunc ` xt @@ cpush ;immed
: lua{ ( * -- * )
	dictionary cpush
	" local dictionary = (...)\n"
	" local function lua(...)\n" ..
	1 backtrack " %b{}" parsematch clips ..
	" \nend\n" ..
	" return lua(select(2, ...))" .. fmt
	Lua.loadstring ccall
	;immed
: lua:( ( -- xt )
	dictionary
	" local dictionary = (...)\n"
	" local function lua(...)\n" ..
	1 backtrack " %b();" parsematch clips ..
	" \nend\n" ..
	" return lua, ..." .. fmt
	Lua.loadstring execute cpush
	;immed
: R@ ( -- x )(C: x -- x ) rstack []@ ;
: Rclear (--)(C: * -- ) rstack []clear ;
// : R?> rstack # 0 > if R> else nil end ;
// : R# rstack # ;
// : R#? R# 0 > ;

// error handling
: throw ( x -- ) 2 Lua.error ;
: try ( compiles: * -- * )
	` [[TRY]] :( ( xt -- xt )
		:( ( [xt] -- *) Lua.pcall )[1]; true
	); cbeginblock
	;immed
: catch ( compiles: * err? b -- * )
	cendblock ( -- xt )
	` [[CATCH]] :( ( xt -- xt )
		:( ( * e? b [xt] -- * ) swap not if execute else drop end )[1];
		true
	); cbeginblock
	;immed
: assert" ( b -- )(TS: "msg")
	// grab the assert string and squirrel it away
	skipch ` [^"]* parsematch >C skipch // " compiles a push to the wrong stack
	// then start compiling the assert cleanup body
	` [[ASSERT]] :( ( xt -- )
		// pass compiled body thread along
		false
	); cbeginblock
	;immed
: ?throw
	cendblock ( -- cleanupthread)
	C>        ( -- cleanupthread msg)
	postpone if ( b -- )
		swap ccall          // compile call to cleanup thread
		cpush ' throw ccall // compile push message and call to throw
	postpone end
	;immed

: {} ( -- {} ) lua{ return {}, ... } ;
: # ( s|t -- n ) lua{ return #(...), select(2, ...) } ;

// some higher level stack manipulations
: nip ( a b -- b ) swap drop ;
: 2dup ( a b -- a b a b ) over over ;
: 3dup ( a b c -- a b c a b c ) 2 pick 2 pick 2 pick ;
// : ndup ( n*x n -- 2n*x ) dup loops dup pick swap end drop ;
: 2drop ( a b -- ) drop drop ;
: 3drop ( a b c -- ) drop drop drop ;
// : ndrop ( n*x n -- ) loops drop end ;
: ?drop ( x b -- x? ) if drop end ;

// a few parser/interpreter/compiler control words
(
: ?deferred ( entry -- )
	` name @@ dup
	create compile // create and start compiling overriding def
		` compiling cpush `lookup ccall postpone if
			lookup ccall // encode a call to original word
		postpone else
			xt execute // exec compiling word, so it can compile to new def
		postpone end
	postpone ;immed
	;
: ;defer   postpone interpret buildfunc dup bindfunc ?deferred ;immed
)
: xt ( {word} -- xt ) ` xt @@ ;
: xt? ( x -- b ) Lua.type ` function = ;
: xt?exec ( * x -- * ) dup xt? if execute end ;
: immediate ( xt|entry -- )
	// redefining to allow making raw XTs immediate i.e. lambdas
	dup xt? not if compile_target.XT @@ end
	immediates true pivot !! drop
	;
: 2word ( -- s1 s2 )(TS: word word ) word word ;
: #! ( * -- * )(TS: word) word lookup execute ;immed

// values and variables
: ! ( x name -- ) dictionary swap !! drop ;
: const ( x name -- )
	TODO: implement as a closure
	create compile
	cpush ' cpush ccall
	postpone ;immed
	TODO: guard against re-binding `name`?
	;
: const: (--)(TS: word x ) 2word resolve xt?exec swap cpush const ;immed
: alias: (--)(TS: new old ) 2word lookup swap ! ;immed
alias: type Lua.type
const: type.xt ` function
const: type.number ` number
const: type.string ` string
const: type.table ` table
const: type.boolean ` boolean
const: type.nil ` nil
: >string ( x -- s ) Lua.tostring ;
: >bool ( x -- b ) not not ;
: >number ( x -- n )
	dup type type.boolean = if
		1 && 0 ||
	else
		dup nil = if drop 0 else string>number end
	end
	;
: executable? ( x -- b )
	dup xt? if
		drop true
	else
		Lua.getmetatable
		dup if ` __call @@ >bool else drop false end
	end
	;
: immediate? ( word -- b )
	dup executable? not if lookup end
	immediates swap @@ >bool // will be nil if not immediate, so cast to bool
	;
// : variable ( name -- entry ) create dup does> NOP ;
// : var: ( x -- ) word variable ! ;immed
// : val: ( x -- ) word variable ! last does> @ ;immed
: ?. dup nil ~= if word resolve xt?exec else word drop end ;immed
: ?? dup nil = if drop word resolve xt?exec else word drop end ;immed

// strings and i/o
const: \r char \r
const: \n char \n
const: \t char \t
const: \v char \v
const: SPACE "  "

const: iostack []
: pushinput  ( fd -- )(IO: fd ) input iostack >[] drop useinput ;
: pushoutput ( fd -- )(IO: fd ) output iostack >[] drop useoutput ;
: popinput  (--)(IO: fd -- ) iostack []> useinput ;
: popoutput (--)(IO: fd -- ) iostack []> useoutput ;

: . ( x -- ) >string .raw SPACE .raw ;
: .char (--)(TS: ch) postpone char ' . ccall ;immed
: ." ( -- )(TS: "s") postpone " ' . ccall ;immed
: .fmt ( * s -- s' ) fmt .raw ;
: .fmt" ( * -- )(TS: "s") postpone " ' .fmt ccall ;immed
: .err ( s -- ) STDERR pushoutput . popoutput ;
: .err" (--)(TS: "s") postpone " ' .err ccall ;immed
: .CR (--) \n .raw ;
: .2CR (--) \n \n .raw .raw ;
: .line ( x -- ) >string .raw .CR ;
: .x ( n -- ) " 0x%x " .fmt ;
: .X ( n -- ) " 0X%X " .fmt ;
: .TAB (--) \t .raw ;
: .C (C: * -- * ) cstack . ;
: .c (C: * -- ) .C Cclear ;
: .R (R: * -- * ) rstack . ;
: .r (R: * -- ) .R Rclear ;
: .s ( * -- ) .S clear ;
: printstack ( * -- ) .fmt" \n<==[ " .S .char ] .CR ;
: see ( word -- )
	dup meta over @@ ( -- word entry? )
	dup if nip else drop meta swap lookup @@ end ( -- entry? )
	dup not if
		drop false lookup_err
	else
		.char : dup ` name @@ .
		` srcbuf @@ each nip . end
		drop
	end
	;
: see: (--)(TS: word ) word see ;immed

// miscellaneous util words and stuff
: NOP ;
alias: NOOP NOP
// : calls: (--) postpone ` " calledby" @@ nip foreach drop " \tcalledby". . .CR end ;
// : calledby: (--) postpone ` " calls" @@ nip foreach drop " \tcalls"   . . .CR end ;

alias: abs Lua.math.abs
alias: ciel Lua.math.ciel
alias: floor Lua.math.floor
alias: add +
alias: sub -
alias: mul *
alias: div /
alias: mod %
alias: pow **
: /% ( n1 n2 -- floor(n1/n2) n1%n2) 2dup / floor -rot % ;
: percent ( n p -- n*(p/100) ) 100 / * ; // e.g. `200 25 percent` => 50
: isnan? ( n -- b ) dup = not ; // nan ≠ nan
: sign ( n -- -1|0|1|nan )
	dup 0 > 1   ( -- n b 1 )       && // collapse
	over 0 < -1 ( -- n 1|#f b -1 ) && // collapse
	||          ( -- n -1|1|#f )
	swap || ;

alias: greater? >
alias: less? <
alias: equal? =
alias: greatereq? >=
alias: lesseq? <=
alias: noteq? ~=

alias: and &&
alias: or ||
alias: xor ^^
alias: nand ~&&
alias: nor ~||

alias: & Lua.bit.band
alias: | Lua.bit.bor
alias: ^ Lua.bit.bxor
alias: ~ Lua.bit.bnot

// control and os words
alias: exit Lua.os.exit
: bye ( * -- )
	printstack
	.fmt" Goodbye 🖤\n"
	0 exit
	;

// copyright, version, banner
: Copyright (--)
	` Copyright create compile
		` Copyright cpush ' . ccall parseline trim cpush ' . ccall ' .2CR ccall
		buildfunc dup bindfunc
	xt ccall
	false immediates ` Copyright !! drop
	;immed
" LICENSE.firth" runfile
alias: © Copyright
const: VERSION " pre-alpha3"
: banner (--) ." :Firth ver." VERSION . .char | © ;
