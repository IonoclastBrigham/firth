char prims.firth drop
char see_comment_block_below_for_copyright_notice drop

char : newentry setcompiling settarget
	interpretpending char %s parse newentry setcompiling settarget
interpret buildfunc bindfunc immediate
: nextword
	char %s parse
interpret buildfunc bindfunc
: postpone
	nextword call
interpret buildfunc bindfunc immediate
: ;
	buildfunc bindfunc postpone interpret
interpret buildfunc bindfunc immediate
: ;immed postpone ; postpone immediate ; immediate

: // char \n parse drop ;immed // There, now we can comment our code!

// /////////////////////////////////////////////////////////////////////////////
// prims.firth
// Basic primitives for low level code and compiler manipulation
// Copyright © 2015 Brigham Toskin
// <https://github.com/IonoclastBrigham/firth/blob/master/LICENSE>
// /////////////////////////////////////////////////////////////////////////////

: " char " parse push ;immed // ( -- s )
: ( char ( >ts " %b()" parsematch drop ;immed ( inline (nestable) single-line comments)

// a few parser/interpreter/compiler control words
: compile ( entry -- C: entry ) interpretpending setcompiling settarget ;
: [ ( -- ) postpone interpret ;immed
: ] ( entry -- C: entry ) compile ; // TODO: alias
: eval ( -- ... )
	postpone [ // TODO: preserve previous value on cstack?
	nextword call
	]
;immed

// strings and such
: ." ( -- ) postpone " char . call ;immed
: CR ( -- ) char \n .raw ;

// values and variables
: const: ( val -- ) postpone : push postpone ; ;immed
// : var: ( val -- ) ;
: ' ( -- entry ) nextword dict ;immed

0.1 const: version
: copyright ." Firth ver." version . ." Copyright © 2015 Brigham Toskin." ;
: © copyright ; // TODO: alias

// some basic arithmetic operators and shortcuts
: + ( a b -- a+b ) char + binop ;immed
: - ( a b -- a-b ) char - binop ;immed
: * ( a b -- a*b ) char * binop ;immed
: / ( a b -- a/b ) char / binop ;immed
: % ( a b -- a%b ) char % binop ;immed
: ** ( a b -- a^b ) char ^ binop ;immed

: 1+ ( n -- n+1 ) 1 char + binopconst ;immed
: inc ( n -- n+1 ) 1+ ; // TODO: alias
: 1- ( n -- n-1 ) 1 char - binopconst ;immed
: dec ( n -- n-1 ) 1- ; // TODO: alias
: -1* ( n -- -n ) -1 char * binopconst ;immed
: neg ( n -- -n ) -1* ; // TODO: alias

: 2+ ( n -- n+2 ) 2 char + binopconst ;immed
: 2- ( n -- n-2 ) 2 char - binopconst ;immed
: 2* ( n -- 2n ) 2 char * binopconst ;immed
: 2/ ( n -- n/2 ) 2 char / binopconst ;immed

: 5+ ( n -- n+5 ) 5 char + binopconst ;immed
: 5- ( n -- n-5 ) 5 char - binopconst ;immed
: 5* ( n -- 5n ) 5 char * binopconst ;immed
: 5/ ( n -- n/5 ) 5 char / binopconst ;immed

: 10+ ( n -- n+10 ) 10 char + binopconst ;immed
: 10- ( n -- n-10 ) 10 char - binopconst ;immed
: 10* ( n -- 10n ) 10 char * binopconst ;immed
: 10/ ( n -- n/10 ) 10 char / binopconst ;immed

: 100+ ( n -- n+100 ) 100 char + binopconst ;immed
: 100- ( n -- n-100 ) 100 char - binopconst ;immed
: 100* ( n -- 100n ) 100 char * binopconst ;immed
: 100/ ( n -- n/100 ) 100 char / binopconst ;immed



// some higher level stack manipulations
: 2dup ( a b -- a b a b ) over over ;
: 3dup ( a b c -- a b c a b c ) 2 pick 2 pick 2 pick ;
: 2drop ( a b -- ) drop drop ;
: 3drop ( a b c -- ) drop drop drop ;

// some basic boolean operators
: > ( a b -- a>b ) char > binop ;immed
: < ( a b -- a<b ) char < binop ;immed
: = ( a b -- a==b ) " ==" binop ;immed
: <= ( a b -- a<=b ) " <=" binop ;immed
: >= ( a b -- a>=b ) " >=" binop ;immed
: ~= ( a b -- a!=b ) " ~=" binop ;immed
: and ( a b -- a&&b ) " and" binop ;immed
: or ( a b -- a||b ) " or" binop ;immed
: nand ( a b -- !a&&b ) postpone and postpone not ;immed
: nor ( a b -- !a||b ) postpone or postpone not ;immed
: xor ( a b -- aXORb ) 2dup or -rot nand and ;
// I think this is kinda cool—if obtuse—so I'm gonna leave it here as a comment:
// : xor 2dup nand dup rot nand -rot nand nand ;
